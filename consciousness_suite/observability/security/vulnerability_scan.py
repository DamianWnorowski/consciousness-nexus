"""Vulnerability Scanner

CVE detection and vulnerability scanning.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Callable
from datetime import datetime
from enum import Enum
import threading
import logging

from prometheus_client import Gauge, Counter

logger = logging.getLogger(__name__)


class Severity(str, Enum):
    """Vulnerability severity levels."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    NEGLIGIBLE = "negligible"
    UNKNOWN = "unknown"


class FixStatus(str, Enum):
    """Fix availability status."""
    FIXED = "fixed"
    NOT_FIXED = "not_fixed"
    WONT_FIX = "wont_fix"
    UNKNOWN = "unknown"


@dataclass
class CVSSScore:
    """CVSS (Common Vulnerability Scoring System) score."""
    version: str  # 2.0, 3.0, 3.1
    score: float  # 0.0 - 10.0
    vector: str  # Attack vector string
    severity: Severity = Severity.UNKNOWN

    def __post_init__(self):
        if self.severity == Severity.UNKNOWN:
            self.severity = self._score_to_severity()

    def _score_to_severity(self) -> Severity:
        """Convert score to severity."""
        if self.score >= 9.0:
            return Severity.CRITICAL
        elif self.score >= 7.0:
            return Severity.HIGH
        elif self.score >= 4.0:
            return Severity.MEDIUM
        elif self.score >= 0.1:
            return Severity.LOW
        return Severity.NEGLIGIBLE


@dataclass
class Vulnerability:
    """A vulnerability finding."""
    vuln_id: str  # CVE-YYYY-NNNNN
    title: str
    description: str
    severity: Severity
    package_name: str
    installed_version: str
    fixed_version: Optional[str] = None
    fix_status: FixStatus = FixStatus.UNKNOWN
    cvss: Optional[CVSSScore] = None
    cwe_ids: List[str] = field(default_factory=list)
    references: List[str] = field(default_factory=list)
    published_date: Optional[datetime] = None
    last_modified: Optional[datetime] = None
    exploitability: str = "unknown"  # none, poc, in_the_wild
    data_source: str = "unknown"

    @property
    def is_fixable(self) -> bool:
        """Check if vulnerability has a fix available."""
        return self.fix_status == FixStatus.FIXED and self.fixed_version is not None

    @property
    def severity_score(self) -> int:
        """Get numeric severity score for sorting."""
        scores = {
            Severity.CRITICAL: 5,
            Severity.HIGH: 4,
            Severity.MEDIUM: 3,
            Severity.LOW: 2,
            Severity.NEGLIGIBLE: 1,
            Severity.UNKNOWN: 0,
        }
        return scores.get(self.severity, 0)


@dataclass
class ScanTarget:
    """Target for vulnerability scanning."""
    target_type: str  # image, filesystem, repository, sbom
    target: str  # Image name, path, URL
    platform: Optional[str] = None  # linux/amd64, etc.
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ScanResult:
    """Result of a vulnerability scan."""
    target: ScanTarget
    scan_time: datetime = field(default_factory=datetime.now)
    duration_seconds: float = 0
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    total_packages: int = 0
    vulnerable_packages: int = 0
    error: Optional[str] = None

    @property
    def is_success(self) -> bool:
        return self.error is None

    @property
    def critical_count(self) -> int:
        return sum(1 for v in self.vulnerabilities if v.severity == Severity.CRITICAL)

    @property
    def high_count(self) -> int:
        return sum(1 for v in self.vulnerabilities if v.severity == Severity.HIGH)

    @property
    def medium_count(self) -> int:
        return sum(1 for v in self.vulnerabilities if v.severity == Severity.MEDIUM)

    @property
    def low_count(self) -> int:
        return sum(1 for v in self.vulnerabilities if v.severity == Severity.LOW)

    @property
    def fixable_count(self) -> int:
        return sum(1 for v in self.vulnerabilities if v.is_fixable)

    def get_by_severity(self, severity: Severity) -> List[Vulnerability]:
        """Get vulnerabilities by severity."""
        return [v for v in self.vulnerabilities if v.severity == severity]

    def get_by_package(self, package: str) -> List[Vulnerability]:
        """Get vulnerabilities for a package."""
        return [v for v in self.vulnerabilities if v.package_name == package]

    def to_summary(self) -> Dict[str, Any]:
        """Get scan summary."""
        return {
            "target": self.target.target,
            "target_type": self.target.target_type,
            "scan_time": self.scan_time.isoformat(),
            "duration_seconds": self.duration_seconds,
            "total_vulnerabilities": len(self.vulnerabilities),
            "critical": self.critical_count,
            "high": self.high_count,
            "medium": self.medium_count,
            "low": self.low_count,
            "fixable": self.fixable_count,
            "total_packages": self.total_packages,
            "vulnerable_packages": self.vulnerable_packages,
            "success": self.is_success,
            "error": self.error,
        }


class VulnerabilityScanner:
    """Scans for vulnerabilities in containers and packages.

    Usage:
        scanner = VulnerabilityScanner()

        # Scan an image
        result = await scanner.scan_image("nginx:latest")

        # Check for critical vulnerabilities
        if result.critical_count > 0:
            print(f"Found {result.critical_count} critical vulnerabilities!")

        # Get fixable vulnerabilities
        fixable = [v for v in result.vulnerabilities if v.is_fixable]
    """

    def __init__(self, namespace: str = "consciousness"):
        self.namespace = namespace

        self._scan_history: List[ScanResult] = []
        self._vulnerability_db: Dict[str, Vulnerability] = {}
        self._lock = threading.Lock()

        self._alert_callbacks: List[Callable[[ScanResult], None]] = []
        self._severity_thresholds: Dict[Severity, int] = {
            Severity.CRITICAL: 0,  # Alert on any critical
            Severity.HIGH: 5,
        }

        # Prometheus metrics
        self.scan_total = Counter(
            f"{namespace}_security_vulnerability_scans_total",
            "Total vulnerability scans",
            ["target_type", "result"],
        )

        self.vulnerabilities_total = Gauge(
            f"{namespace}_security_vulnerabilities_total",
            "Total vulnerabilities found",
            ["severity"],
        )

        self.vulnerabilities_by_image = Gauge(
            f"{namespace}_security_vulnerabilities_by_image",
            "Vulnerabilities by image",
            ["image", "severity"],
        )

        self.scan_duration = Gauge(
            f"{namespace}_security_scan_duration_seconds",
            "Scan duration",
            ["target_type"],
        )

        self.fixable_vulnerabilities = Gauge(
            f"{namespace}_security_fixable_vulnerabilities",
            "Fixable vulnerabilities",
            ["image"],
        )

    def set_alert_threshold(self, severity: Severity, threshold: int):
        """Set alert threshold for severity.

        Args:
            severity: Severity level
            threshold: Alert if count exceeds this
        """
        self._severity_thresholds[severity] = threshold

    def on_alert(self, callback: Callable[[ScanResult], None]):
        """Register alert callback.

        Args:
            callback: Function to call with ScanResult
        """
        self._alert_callbacks.append(callback)

    async def scan_image(
        self,
        image: str,
        platform: Optional[str] = None,
    ) -> ScanResult:
        """Scan a container image for vulnerabilities.

        Args:
            image: Image name (e.g., nginx:latest)
            platform: Target platform

        Returns:
            ScanResult
        """
        target = ScanTarget(
            target_type="image",
            target=image,
            platform=platform,
        )

        # This is a placeholder - in real implementation,
        # would call Trivy, Grype, or other scanner
        logger.info(f"Scanning image: {image}")

        result = ScanResult(
            target=target,
            total_packages=0,
        )

        self._process_result(result)
        return result

    async def scan_filesystem(
        self,
        path: str,
    ) -> ScanResult:
        """Scan a filesystem path for vulnerabilities.

        Args:
            path: Filesystem path

        Returns:
            ScanResult
        """
        target = ScanTarget(
            target_type="filesystem",
            target=path,
        )

        logger.info(f"Scanning filesystem: {path}")

        result = ScanResult(
            target=target,
            total_packages=0,
        )

        self._process_result(result)
        return result

    async def scan_sbom(
        self,
        sbom_path: str,
    ) -> ScanResult:
        """Scan an SBOM for vulnerabilities.

        Args:
            sbom_path: Path to SBOM file

        Returns:
            ScanResult
        """
        target = ScanTarget(
            target_type="sbom",
            target=sbom_path,
        )

        logger.info(f"Scanning SBOM: {sbom_path}")

        result = ScanResult(
            target=target,
            total_packages=0,
        )

        self._process_result(result)
        return result

    def record_vulnerability(self, vuln: Vulnerability):
        """Record a vulnerability finding.

        Args:
            vuln: Vulnerability to record
        """
        with self._lock:
            self._vulnerability_db[vuln.vuln_id] = vuln

    def record_scan_result(self, result: ScanResult):
        """Record a scan result.

        Args:
            result: Scan result to record
        """
        self._process_result(result)

    def _process_result(self, result: ScanResult):
        """Process and store scan result."""
        with self._lock:
            self._scan_history.append(result)

            # Keep only recent history
            if len(self._scan_history) > 1000:
                self._scan_history = self._scan_history[-500:]

            # Store vulnerabilities
            for vuln in result.vulnerabilities:
                self._vulnerability_db[vuln.vuln_id] = vuln

        # Update metrics
        status = "success" if result.is_success else "error"
        self.scan_total.labels(
            target_type=result.target.target_type,
            result=status,
        ).inc()

        self.scan_duration.labels(
            target_type=result.target.target_type,
        ).set(result.duration_seconds)

        # Vulnerability counts
        for severity in Severity:
            count = len(result.get_by_severity(severity))
            self.vulnerabilities_total.labels(severity=severity.value).set(count)

            if result.target.target_type == "image":
                self.vulnerabilities_by_image.labels(
                    image=result.target.target[:50],  # Truncate for cardinality
                    severity=severity.value,
                ).set(count)

        if result.target.target_type == "image":
            self.fixable_vulnerabilities.labels(
                image=result.target.target[:50],
            ).set(result.fixable_count)

        # Check thresholds and trigger alerts
        self._check_alerts(result)

    def _check_alerts(self, result: ScanResult):
        """Check if result triggers alerts."""
        should_alert = False

        for severity, threshold in self._severity_thresholds.items():
            count = len(result.get_by_severity(severity))
            if count > threshold:
                should_alert = True
                logger.warning(
                    f"Vulnerability alert: {count} {severity.value} vulnerabilities "
                    f"in {result.target.target} (threshold: {threshold})"
                )

        if should_alert:
            for callback in self._alert_callbacks:
                try:
                    callback(result)
                except Exception as e:
                    logger.error(f"Alert callback error: {e}")

    def get_vulnerability(self, vuln_id: str) -> Optional[Vulnerability]:
        """Get a vulnerability by ID.

        Args:
            vuln_id: CVE ID

        Returns:
            Vulnerability or None
        """
        with self._lock:
            return self._vulnerability_db.get(vuln_id)

    def get_all_vulnerabilities(
        self,
        severity: Optional[Severity] = None,
        fixable_only: bool = False,
    ) -> List[Vulnerability]:
        """Get all known vulnerabilities.

        Args:
            severity: Filter by severity
            fixable_only: Only return fixable

        Returns:
            List of vulnerabilities
        """
        with self._lock:
            vulns = list(self._vulnerability_db.values())

        if severity:
            vulns = [v for v in vulns if v.severity == severity]

        if fixable_only:
            vulns = [v for v in vulns if v.is_fixable]

        # Sort by severity
        vulns.sort(key=lambda v: v.severity_score, reverse=True)

        return vulns

    def get_scan_history(
        self,
        target_type: Optional[str] = None,
        limit: int = 100,
    ) -> List[ScanResult]:
        """Get scan history.

        Args:
            target_type: Filter by target type
            limit: Maximum results

        Returns:
            List of scan results
        """
        with self._lock:
            results = list(self._scan_history)

        if target_type:
            results = [r for r in results if r.target.target_type == target_type]

        # Most recent first
        results.sort(key=lambda r: r.scan_time, reverse=True)

        return results[:limit]

    def get_summary(self) -> Dict[str, Any]:
        """Get vulnerability summary.

        Returns:
            Summary dictionary
        """
        with self._lock:
            vulns = list(self._vulnerability_db.values())
            scans = list(self._scan_history)

        by_severity: Dict[str, int] = {}
        for severity in Severity:
            by_severity[severity.value] = sum(1 for v in vulns if v.severity == severity)

        fixable = sum(1 for v in vulns if v.is_fixable)

        # Recent scan stats
        recent_scans = scans[-10:] if scans else []
        avg_duration = (
            sum(s.duration_seconds for s in recent_scans) / len(recent_scans)
            if recent_scans else 0
        )

        # Most vulnerable packages
        package_counts: Dict[str, int] = {}
        for v in vulns:
            package_counts[v.package_name] = package_counts.get(v.package_name, 0) + 1
        top_packages = sorted(package_counts.items(), key=lambda x: x[1], reverse=True)[:10]

        return {
            "total_vulnerabilities": len(vulns),
            "by_severity": by_severity,
            "fixable_count": fixable,
            "unique_packages_affected": len(package_counts),
            "total_scans": len(scans),
            "avg_scan_duration": avg_duration,
            "top_vulnerable_packages": [
                {"package": p, "count": c} for p, c in top_packages
            ],
        }
